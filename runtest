#!/usr/bin/python
# -*- coding: utf-8 -*-

"""

Connect to the REST API of a Noark 5 service and check that it behaves
as it should.  See also http://rel.kxml.no/noark5/konformitetsniva/

"""
# Copyright (C) 2017 Petter Reinholdtsen <pere@hungry.com>
#
# Licensed under the GNU General Public License Version 2
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import sys
sys.path.append('lib')

import argparse
import json
import mechanize
import urlparse
import urllib2
import xml.etree.ElementTree
import n5core.endpoint

class Noark5Tester (n5core.endpoint.Endpoint):
    knownrels = [
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/arkiv/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/arkivdel/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/arkivskaper/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/basisregistrering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/dokumentbeskrivelse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/dokumentobjekt/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/elektronisksignatur/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/fil/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/klasse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/klassifikasjonssystem/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/konvertering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/kryssreferanse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/mappe/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/merknad/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkiv/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkivdel/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkivskaper/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-basisregistrering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-dokumentbeskrivelse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-dokumentobjekt/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-elektronisksignatur/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-klasse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-klassifikasjonssystem/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-konvertering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-kryssreferanse/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-mappe/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-merknad/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-registrering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/registrering/',
        'http://rel.kxml.no/noark5/v4/api/arkivstruktur/underarkiv/',
        'http://rel.kxml.no/noark5/v4/api/metadata/arkivdelstatus/',
        'http://rel.kxml.no/noark5/v4/api/metadata/arkivstatus/',
        'http://rel.kxml.no/noark5/v4/api/metadata/dokumentmedium/',
        'http://rel.kxml.no/noark5/v4/api/metadata/dokumentstatus/',
        'http://rel.kxml.no/noark5/v4/api/metadata/dokumenttype/',
        'http://rel.kxml.no/noark5/v4/api/metadata/elektronisksignatursikkerhetsnivaa/',
        'http://rel.kxml.no/noark5/v4/api/metadata/elektronisksignaturverifisert/',
        'http://rel.kxml.no/noark5/v4/api/metadata/format/',
        'http://rel.kxml.no/noark5/v4/api/metadata/graderingskode/',
        'http://rel.kxml.no/noark5/v4/api/metadata/journalposttype/',
        'http://rel.kxml.no/noark5/v4/api/metadata/journalstatus/',
        'http://rel.kxml.no/noark5/v4/api/metadata/kassasjonsvedtak/',
        'http://rel.kxml.no/noark5/v4/api/metadata/saksstatus/',
        'http://rel.kxml.no/noark5/v4/api/metadata/skjermingdokument/',
        'http://rel.kxml.no/noark5/v4/api/metadata/skjermingmetadata/',
        'http://rel.kxml.no/noark5/v4/api/metadata/slettingstype/',
        'http://rel.kxml.no/noark5/v4/api/metadata/tilknyttetregistreringsom/',
        'http://rel.kxml.no/noark5/v4/api/metadata/variantformat/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/avskrivning/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/dokumentflyt/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/journalpost/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/korrespondansepart/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-avskrivning/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-dokumentflyt/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-journalpost/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-korrespondansepart/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-presedens/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-saksmappe/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-sakspart/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/presedens/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/saksmappe/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/saksparter/',
        'http://rel.kxml.no/noark5/v4/api/sakarkiv/sekundaerklassifikasjon/',
        'self',
    ]
    verbose = False
    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument("--reference", help="connect to demo API site",
                            action="store_true")
        parser.add_argument("--verbose", help="enable debug output",
                            action="store_true")
        args = parser.parse_args()
        if args.reference:
            self.baseurl = "http://n5test.kxml.no/api/"
        else:
            self.baseurl = "http://localhost:8092/noark5v4/"
        n5core.endpoint.Endpoint.__init__(self,self.baseurl)
        self.verbose = args.verbose
        self.failures = {}
        self.xfailures = {}
        self.successes = {}
    def success(self, msg):
        if msg not in self.successes:
            self.successes[msg] = 1
            print "success: " + msg
        return True
    def failure(self, msg):
        if msg not in self.failures:
            self.failures[msg] = 1
            print "failure: " + msg
        return False
    def verify(self, check, msg):
        if (check):
            return self.success(msg)
        else:
            return self.failure(msg)
    def xfailure(self, msg):
        if msg not in self.xfailures:
            self.xfailures[msg] = 1
            print "xfailure: " + msg
        return False
    def xverify(self, check, msg):
        if (check):
            return self.success(msg)
        else:
            return self.xfailure(msg)

    def verifyuniquerels(self, links, url):
        currels = {}
        for l in links:
            rel = l['rel']
            if rel in currels:
                self.failure("duplicate rel %s in _links for %s" % (rel, url))
            else:
                currels[l['rel']] = url

    def recursiveHateoas(self):
        if self.verbose:
            print "recursively discovering standard URLs from the top"
        relok = {}
        for r in self.knownrels:
            relok[r] = True
        self.urls = []
        self.rels = {}
        urlsleft = ['.']
        urlseen = {}
        while 0 < len(urlsleft):
            url = urlsleft.pop(0)
            if url in urlseen:
                continue
            urlseen[url] = 1
            try:
                (content, res) = self.json_get(url)
                ctype = res.info().getheader('Content-Type')
                if self.verify(0 == ctype.find('application/vnd.noark5-v4+json'),
                               "MIME type %s should be application/vnd.noark5-v4+json for url %s" % (ctype, url)):
                    #print "C:", content
                    baseref = json.loads(content)
                    #print "J:", baseref
                    if baseref is None:
                        self.failure("JSON MIME type but no JSON in %s" % url)
                    elif type(baseref) is list:
                        self.failure("found json list in %s" % url)
                    elif '_links' in baseref:
                        self.verifyuniquerels(baseref['_links'], url)
                        for l in baseref['_links']:
                            # Ignore non-standard relations
                            if 'href' in l and \
                               -1 != l['rel'].find("//rel.kxml.no/noark5/"):
                                href = l['href']
                                if href not in urlseen:
                                    urlsleft.append(href)
                                # The spec do not say if 'templated' is required or not
                                #if 'templated' not in l:
                                #    self.failure("_links missing templated in %s" % url)
                                if 'templated' in l and l['templated']:
                                    hrefshort = href.split('{')[0]
                                    if hrefshort not in urlseen:
                                        urlsleft.append(hrefshort)
                                if 'rel' in l and l['rel'] != 'self':
                                    # FIXME figure out if rels should match spec
                                    if l['rel'] in relok:
                                        self.success('rel %s is well known' % l['rel'])
                                    elif l['rel'] + '/' in relok:
                                        self.success('rel %s is well known (missing trailing slash)' % l['rel'])
                                    else:
                                        self.failure('rel %s in %s should be well known' % (l['rel'], url))
                                    rel = l['rel']
                                    # Only check non-objects for unique relations
                                    if 'systemID' not in baseref \
                                       and rel in self.rels \
                                       and href != self.rels[rel]:
                                        self.failure("unique duplicate rel %s in _links for %s" % (rel, url))
                                    else:
                                        self.rels[rel] = href
                    else:
                        self.failure("GET %s missing _links" % url)
                    if baseref is not None and type(baseref) is not list:
                        for basekey in baseref.keys():
                            if basekey != '_links' and type(baseref[basekey]) is list:
                                if 0 < len(baseref[basekey]):
                                    element = baseref[basekey][0]
                                    #print(element)
                                    if '_links' in element and len(element['_links']) > 0:
                                        self.verifyuniquerels(element['_links'], url)
                                        for l in element['_links']:
                                            href = l['href']
                                            if href not in urlseen:
                                                #self.failure("Found new link %s" % href)
                                                urlsleft.append(href)
                self.urls.append(url)
                try:
                    # Check if CORS can work for the URL
                    (ocontent, ores) = self.options(url)
                except urllib2.HTTPError, e:
                    self.failure("unable to OPTIONS %s" % url)
            except urllib2.HTTPError, e:
                self.failure("unable to GET %s" % url)
        for url in sorted(self.urls):
            self.success("found %s" % url)
        for rel in sorted(self.rels.keys()):
            if self.verbose:
                print("mapping %s to %s" % (rel, self.rels[rel]))

    def verifyAuthentication(self):
        """
level 0 authentication.  Verify that a URL requiring login
will contain the WWW-Authenticate header and return HTTP
code 401 before logging in.
"""
        try:
            # FIXME figure out a way avoid hardcoding this URL
            url = "arkivstruktur/arkiv/"
            (content, res) = self.json_get(url)
            self.failure("level 0 accessing %s before login do not ask for basic authentication" % url)
        except urllib2.HTTPError, e:
            self.xverify(401 == e.code and 'www-authenticate' in e.hdrs,
                        "level 0 API should support support Basic access authentication")
        
    def verifyXML(self, prefix, xmlreq, xmlcontent):
        validlinktags = {
            '{http://www.kxml.no/rest/1.0}rel':1,
            '{http://www.kxml.no/rest/1.0}href':1,
            '{http://www.kxml.no/rest/1.0}type':1,
            '{http://www.kxml.no/rest/1.0}deprecation':1,
            '{http://www.kxml.no/rest/1.0}name':1,
            '{http://www.kxml.no/rest/1.0}title':1,
        }
        #print content
        #print xmlreq
        contenttype = xmlreq.info().getheader('Content-Type')
        if 0 != contenttype.find('application/vnd.noark5-v4+xml'):
            self.failure('level 0 XML - incorrect Content-Type for base: %s' % contenttype)
        else:
            self.success(prefix + ' - correct Content-Type for base')
            root = xml.etree.ElementTree.fromstring(xmlcontent)
            #print root.tag, root.attrib
            if self.xverify("{http://www.kxml.no/rest/1.0}Links" == root.tag, "root XML tag should be <Links xmlns=\"http://www.kxml.no/rest/1.0\" ...>"):
                for child in root:
                    if self.verify("{http://www.kxml.no/rest/1.0}Links" == child.tag, "first child XML tag should be <Links xmlns=\"http://www.kxml.no/rest/1.0\">"):
                        for subchild in child:
                            #print subchild.tag
                            if self.verify("{http://www.kxml.no/rest/1.0}link" == subchild.tag, "second child XML tag should be <links xmlns=\"http://www.kxml.no/rest/1.0\">"):
                                for link in subchild:
                                    #print link
                                    self.verify(link.tag in validlinktags,
                                                '<Links><Links><link> content should have well known tags')

    def testBasis(self):
        """
Test basis requirements for NOARK 5 Core.

"""
        # Verify CORS support,
        # https://en.wikipedia.org/wiki/Cross-origin_resource_sharing
        try:
            (ocontent, ores) = self.options('.')
            self.success("level 0 CORS - HTTP OPTTIONS request worked")
        except urllib2.HTTPError, e:
            self.failure("level 0 CORS - HTTP OPTTIONS request not working")
        except urllib2.URLError:
            self.failure("level 0 CORS - unable to connect via HTTP")

        self.verifyAuthentication()

        # Verify ability to produce XML output
        try:
            (content, res) = self.xml_get(".")
            self.verifyXML('level 0 XML', res, content)
        except urllib2.HTTPError, e:
            self.failure("level 0 XML - unable to GET content for base.")
            print("FAIL: %s" % e.read())

        # Verify ability to produce JSON output
        try:
            (content, res) = self.json_get(".")
            self.success("level 0 JSON - found base")
            contenttype = res.info().getheader('Content-Type')
            if 0 != contenttype.find('application/vnd.noark5-v4+json'):
                self.failure('level 0 JSON - incorrect content-type for base: %s' % contenttype)
            else:
                self.success('level 0 JSON - correct content-type for base')
                baseref = json.loads(content)
#                print d
                if '_links' in baseref:
                    self.success('level 0 JSON - found _links in json response')
                    return baseref
                else:
                    self.failure('level 0 JSON - did not find _links in json response')
        except urllib2.HTTPError, e:
            self.failure('level 0 JSON - unable to GET JSON content for base.')

        # FIXME Verify authentication, not sure how
        return None

    def parselinks(self,links):
        rels = {}
        for l in links:
            if 'href' in l and 'rel' in l:
                rels[l['rel']] = l['href']
        return rels

    def createEntity(self, name, rel, rels, data):
        print("trying to create %s" % name)
        if rel not in rels:
            self.failure("unable to create a new %s, no %s entry discovered even if logged in" % (name, rel))
            return
        url = rels[rel]
        try:
            (gc, gres) = self.json_get(url)
            default = json.loads(gc)
            print("GET %s returned %s" % (url, default))
            # using default values in POST
            for k in default.keys():
                if not k == '_links' and k not in data:
                    data[k] = default[k]
            self.success("GET %s worked" % url)
            try:
                # Verify OPTIONS announce POST support 
                (ocontent, ores) = self.options(url)
                allow = ores.info().getheader('Allow').split(',')
                self.verify(-1 != allow.index('POST'), 'OPTIONS header Allow should include POST for %s' % url)
            except urllib2.HTTPError, e:
                self.failure('unable to OPTIONS %s' % url)
        except urllib2.HTTPError, e:
            self.failure('unable to GET %s' % url)
        print("POST %s: %s" % (url, data))
        try:
            (c, res) = self.json_post(url, data)
        except urllib2.HTTPError, e:
            self.failure("POST %s failed: %s" % (url, e.read().decode('UTF-8')))
            raise
        info = json.loads(c)
        id = info['systemID']
        self.verify(id is not None, "created %s" % name)
        self.verify(201 == res.code, "%s creationg returned HTTP code 201" % name)
        self.verifyuniquerels(info['_links'], url)
        linkrefs = self.parselinks(info['_links'])
        self.verify('self' in linkrefs, "_links in response from %s creation should include 'self' reference" % name)
        return info

    def testNewDocument(self):
        import datetime
        now = datetime.datetime.now().isoformat()
        if not self.gotlogin:
            self.failure("not logged in, unable to test creation")
            return

        createrecordcreatorrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkivskaper/'
        recordcreatordata = {
        }
        recordcreatorinfo = self.createEntity('recordcreator',
                                            createrecordcreatorrel, self.rels,
                                            recordcreatordata)
        if recordcreatorinfo is None:
            return
            
        createfondsrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkiv/'
        fondsdata = {
#            "tittel"          : "Title of the test fonds created %s" % now,
#            "beskrivelse"     : "Description of the test fonds",
#            "oppbevaringsted" : [ "location 1", "location2", "location3" ],
#            "dokumentmedium"  : "Elektronisk arkiv",
        }
        fondinfo = self.createEntity('fonds', createfondsrel,
                                     self.parselinks(recordcreatorinfo['_links']),
                                     fondsdata)
        if fondinfo is None:
            return
            
        seriesdata = {
#            "tittel"          : "Title of the test series created %s" % now,
#            "beskrivelse"     : "Description of the test series",
#            "oppbevaringsted" : [ "location 1", "location2", "location3" ],
#            "dokumentmedium"  : "Elektronisk arkiv",
        }
        createseriesrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-arkivdel/'
        serieinfo = self.createEntity('serie', createseriesrel,
                                      self.parselinks(fondinfo['_links']),
                                      seriesdata)
        
        filedata = {
#            "mappeID"            : "2017/01",
#            "offentligTittel"    : "Public title of the test file created %s" % now,
#            "tittel"             : "Title of the test file created %s" % now,
#            "beskrivelse"        : "Description of the test file",
#            "noekkelord"         : ["nøkkelord 1", "nøkkelord 2"],
#            "oppbevaringsted"    : [ "location 1", "location2", "location3" ],
#            "dokumentmedium"     : "Elektronisk arkiv",
        }
        createfilerel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-mappe/'
        fileinfo = self.createEntity('file', createfilerel,
                                     self.parselinks(serieinfo['_links']),
                                     filedata)

        casefiledata = {
#            "mappeID"            : "2017/1",
#            "offentligTittel"    : "Public title of the test case file created %s" % now,
#            "tittel"             : "Title of the test case file created %s" % now,
#            "beskrivelse"        : "Description of the test file",
#            "noekkelord"         : ["nøkkelord 1", "nøkkelord 2"],
#            "oppbevaringsted"    : [ "location 1", "location2", "location3" ],
#            "dokumentmedium"     : "Elektronisk arkiv",
#            "saksdato"           : "2016-10-04",
#            "administrativEnhet" : "The administrative unit",
#            "saksansvarlig"      : "Joe the case handler",
#            "saksstatus"         : "Opprettet",
        }
        createcasefilerel = \
            'http://rel.kxml.no/noark5/v4/api/sakarkiv/ny-saksmappe/'
        casefileinfo = self.createEntity('casefile', createcasefilerel,
                                         self.parselinks(serieinfo['_links']),
                                         casefiledata)

        recorddata = {
        }
        createrecordrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-registrering/'
        recordinfo = self.createEntity('record', createrecordrel,
                                       self.parselinks(fileinfo['_links']),
                                       recorddata)

        docdescdata = {
#            "dokumenttype"    : "type dokument",
#            "dokumentstatus"  : "status of document",
#            "tittel"          : "Title of the test document description created %s" % now,
#            "tilknyttetRegistreringSom" : "Associated with record as"
        }
        createdocdescrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-dokumentbeskrivelse/'
        docdescinfo = self.createEntity('document description',
                                        createdocdescrel,
                                        self.parselinks(recordinfo['_links']),
                                        docdescdata)

        xmldata = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><xml></xml>\n"
        docobjdata = {
#            "versjonsnummer"  : 1,
#            "variantformat"   : "Arkivformat",
#            "format"          : "PDF",
#            "formatDetaljer"  : "PDF/A PDFv1.4",
            "filstoerrelse"   : len(xmldata),
#            "mimeType"       : "application/xml", 
        }
        createdocobjrel = \
            'http://rel.kxml.no/noark5/v4/api/arkivstruktur/ny-dokumentobjekt/'
        docobjinfo = self.createEntity('document object', createdocobjrel,
                                       self.parselinks(docdescinfo['_links']),
                                       docobjdata)

        # FIXME try to upload a file, for examle an xml file and large
        # chunked file.
        reffilerel = 'http://rel.kxml.no/noark5/v4/api/arkivstruktur/fil/'
        self.verify(reffilerel in self.parselinks(docobjinfo['_links']),
                    "_links in response from %s rel should include '%s' rel" % (createdocobjrel, reffilerel))
        rels = self.parselinks(docobjinfo['_links'])
        url = rels[reffilerel]
        try:
            (c, res) = self.post(url, xmldata, 'application/xml')
            # The spec is not clear on what is returned from file upload
            #self.verify(c == '', "POST %s return nothing" % url)
            self.verify(200 == res.code, "file upload returned HTTP code 200")
        except urllib2.HTTPError, e:
            print("POST %s failed: %s" % (url, e.read()))

    def runtests(self):
        try:
            baseref = self.testBasis()
            self.recursiveHateoas()
            try:
                self.login()
                self.gotlogin = True
                self.success("able to log in using admin/password")
            except urllib2.HTTPError, e:
                self.gotlogin = False
                self.failure("unable to log in, operating in read only mode: %s" % e)
            self.recursiveHateoas()
            self.testNewDocument()
            self.recursiveHateoas()
            self.testNewDocument()
        finally:
            print("%d successes, %d failures, %d expected failures"
                  % (len(self.successes.keys()),
                     len(self.failures.keys()),
                     len(self.xfailures.keys())))
        return not (0 == len(self.failures.keys()))
def main():
    t = Noark5Tester()
    return t.runtests()

if __name__ == '__main__':
    exit(main())
