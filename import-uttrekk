#!/usr/bin/env python
"""

Import a Noark 5 extract into the API.

Test data can be found in
../noark5-validator-k/src/resources/test-uttrekk/uttrekk1/n5uttrekk

"""

from __future__ import print_function

__license__ = 'GNU General Public License v2 or later at users choice'
__author__ = 'Petter Reinholdtsen'

import sys
sys.path.append('lib')

import argparse
import json
import os
import urllib2
from lxml import etree

import n5core.endpoint

# FIXME figure out a better way to handle formats?
formatmap = {
    'pdf':   ('PDF', 'application/pdf'),
    'pdf/a': ('RA-PDF', 'application/pdf'),
    'text':  ('RA-TEXT', 'text/plain'),
}

strukturns = 'http://www.arkivverket.no/standarder/noark5/arkivstruktur'

tagarkiv                 = '{%s}arkiv' % strukturns
tagarkivdel              = '{%s}arkivdel' % strukturns
tagklassifikasjonssystem = '{%s}klassifikasjonssystem' % strukturns
tagklasse                = '{%s}klasse' % strukturns
tagmappe                 = '{%s}mappe' % strukturns
tagregistrering          = '{%s}registrering' % strukturns
tagdokumentbeskrivelse   = '{%s}dokumentbeskrivelse' % strukturns
tagdokumentobjekt        = '{%s}dokumentobjekt' % strukturns

# Copied from import-email
def parselinks(links):
    rels = {}
    for l in links:
        if 'href' in l and 'rel' in l:
            rels[l['rel']] = l['href']
    return rels

class Importer(n5core.endpoint.Endpoint):
    relbase = 'http://rel.kxml.no/noark5/v4/api'
    
    def __init__(self, baseurl):
        self.nesting = 0
        self.dryrun = False
        n5core.endpoint.Endpoint.__init__(self, baseurl)
        self.stats = {}

    def output(self, msg):
        print("%s %s" % ('=' * self.nesting, msg))

    def printstats(self):
        print("Imported entries and their count")
        for name in sorted(self.stats.keys()):
            print("%-25s %d" % (name, self.stats[name]))

    # Copied from import-email
    def create_entity(self, name, rel, rels, data):
        if rel not in rels:
            raise Exception("unable to find %s in provided relations" % rel)
        url = rels[rel]
        try:
            if self.verbose:
                print("GET %s" % url)
            (gc, gres) = self.json_get(url)
            default = json.loads(gc)
            for k in default.keys():
                if not k == '_links' and k not in data:
                    data[k] = default[k]
        except urllib2.HTTPError as e:
            pass
        try:
            if self.verbose:
                print("POST: %s" % data)
            (c, res) = self.json_post(url, data)
            if name not in self.stats:
                self.stats[name] = 0
            self.stats[name] += 1
        except urllib2.HTTPError as e:
            msg = e.read()
            print("Error: ", msg)
            raise
        info = json.loads(c)
        if self.verbose:
            # Validate the stuff we send came back after storing
            for f in data.keys():
                if data[f] is not None:
                    if  f not in info:
                        print("error: field %s=%s disappeared from object" %  (f, data[f]))
                    elif data[f] != info[f]:
                        print("error: field %s=%s do not match object value %s" %  (f, data[f], info[f]))
        return info

    # Copied from import-email
    def object_operation(self, info, relation):
        """
Return the URL/href for a given relation on the object represented by
the json structure.

    """
        if info is None or '_links' not in info:
            return None
        for l in info['_links']:
            if l['rel'] == relation:
                return l['href']
        return None

    def import_entity(self, name, rel, parentinfo, element, subs, exclude=()):
        self.nesting += 1
        data = {}
        for sub in element.iterchildren():
            if self.verbose:
                self.output("%s: '%s' - '%s'" % (name, sub.tag, sub.text))
            if sub.tag in subs:
                subs[sub.tag][0].append(sub)
            field = sub.tag.replace('{%s}' % strukturns, '')
            if None != sub.text:
                if field not in exclude:
                    data[field] = sub.text
                else:
                    self.output('ignoring %s field %s [%s]' % (name, field, sub.text))
        if self.verbose or self.dryrun:
            self.output("POST: %s" % data)
        if self.dryrun:
            info = None
        else:
            if self.verbose:
                print()
                print("Creating %s: %s" % (name, data))
                print()
            info = self.create_entity(name, rel,
                                         parselinks(parentinfo['_links']),
                                         data)
        for tag in subs.keys():
            for sub in subs[tag][0]:
                subs[tag][1](info, sub)
        self.nesting -= 1
        return info

    def import_arkiv(self, parentinfo, element):
        subs = {
            tagarkivdel: ([], self.import_arkivdel),
        }
        rel = self.relbase + '/arkivstruktur/ny-arkiv/'
        self.import_entity('arkiv', rel, parentinfo, element, subs)

    def import_arkivdel(self, parentinfo, element):
        subs = {
            tagmappe: ([], self.import_mappe),
            tagklassifikasjonssystem: ([], self.import_klassifikasjonssystem),
        }
        rel = self.relbase + '/arkivstruktur/ny-arkivdel/'
        self.import_entity('arkivdel', rel, parentinfo, element, subs)

    def import_klassifikasjonssystem(self, parentinfo, element):
        subs = {
            tagklasse: ([], self.import_klasse),
        }
        rel = self.relbase + '/arkivstruktur/ny-klassifikasjonssystem/'
        self.import_entity('klassifikasjonssystem', rel, parentinfo, element, subs)

    def import_klasse(self, parentinfo, element):
        subs = {
            tagmappe: ([], self.import_mappe),
        }
        rel = self.relbase + '/arkivstruktur/ny-klasse/'

        # FIXME ignore these while nikita fail to understand it
        exclude = ('noekkelord')

        self.import_entity('klasse', rel, parentinfo, element, subs, exclude=exclude)

    def import_mappe(self, parentinfo, element):
        attrtype = '{http://www.w3.org/2001/XMLSchema-instance}type'
        name = 'mappe'
        rel = self.relbase + '/arkivstruktur/ny-mappe/'
        exclude = ()
        if attrtype in element.keys():
            etype = element.get(attrtype)
            if 'moetemappe' == etype:
                name = 'moetemappe'
                rel = self.relbase + '/arkivstruktur/ny-moetemappe/'
            elif 'saksmappe' == etype:
                name = 'saksmappe'
                rel = self.relbase + '/sakarkiv/ny-saksmappe/'
                exclude = (
                    # FIXME create these before using
                    'administrativEnhet', 'saksansvarlig',
                    # These seem to conflict with something else?
                    #'mappeID',
                    #'saksaar', 'sakssekvensnummer',
                )
            else:
                raise ValueError("unknown %s type %s" % (element.tag, etype))
        subs = {
            tagregistrering: ([], self.importRegistrering),
        }
        self.import_entity(name, rel, parentinfo, element, subs, exclude=exclude)

    def importRegistrering(self, parentinfo, element):
        name = 'registrering'
        rel = self.relbase + '/arkivstruktur/ny-registrering/'
        attrtype = '{http://www.w3.org/2001/XMLSchema-instance}type'
        if attrtype in element.keys():
            etype = element.get(attrtype)
            if 'journalpost' == etype:
                name = 'journalpost'
                rel = self.relbase + '/arkivstruktur/ny-journalpost/'
            elif 'moeteregistrering' == etype:
                name = 'moeteregistrering'
                rel = self.relbase + '/arkivstruktur/ny-moeteregistrering/'
            elif 'basisregistrering' == etype:
                name = 'basisregistrering'
                rel = self.relbase + '/arkivstruktur/ny-basisregistrering/'
            else:
                raise ValueError("unknown %s type %s" % (element.tag, etype))
        subs = {
            tagdokumentbeskrivelse: ([], self.import_dokumentbeskrivelse),
        }

        # FIXME ignore these while nikita fail to understand it
        exclude = ('noekkelord')

        self.import_entity(name, rel, parentinfo, element, subs, exclude=exclude)

    def import_dokumentbeskrivelse(self, parentinfo, element):
        subs = {
            tagdokumentobjekt: ([], self.import_dokumentobjekt),
        }
        rel = self.relbase + '/arkivstruktur/ny-dokumentbeskrivelse/'

        # FIXME ignore these while nikita fail to understand it
        exclude = ('forfatter','referanseArkivdel')

        self.import_entity('dokumentbeskrivelse', rel, parentinfo, element, subs,
                           exclude=exclude)

    def import_dokumentobjekt(self, parentinfo, element):
        rel = self.relbase + '/arkivstruktur/ny-dokumentobjekt/'

        # Exclude values related to the files that are handled during
        # upload and not during dokumentobjekt creation.  Dropping
        # filestoerrelse might seem like a bad idea, but it is most
        # often a free text field that is hard to parse and incorrect
        # file size would also give a checksum mismatch.  Thus
        # incorrect file size would be detected during upload that
        # way.
        exclude = ('referanseDokumentfil', 'filstoerrelse')

        info = self.import_entity('dokumentobjekt', rel, parentinfo, element, {},
                                  exclude=exclude)
        
        paths = list(element.iterchildren('{%s}referanseDokumentfil' % strukturns))
        if 1 < len(paths):
            raise ValueError('more than one referanseDokumentfil field is not allowed')
        filepath = os.path.join(self.basedir, paths[0].text)
        try:
            with open(filepath) as content:
                size = os.path.getsize(filepath)
                format = formatmap[info['format']][1]
                print("Opened %s size %d format %s" % (filepath, size, format))
                uploadrel = self.relbase + '/arkivstruktur/fil/'
                newfilehref = self.object_operation(info, uploadrel)
                if not self.dryrun:
                    try:
                        (c, res) = self.post(str(newfilehref), content,
                                             format, length=size)
                    except urllib2.HTTPError as e:
                        msg = e.read()
                        self.output('unable to POST to %s: %s' % (newfilehref, msg))
                        raise
        except IOError as e:
            self.output('unable to open %s' % filepath)
            raise

    def loaddir(self, basedir):
        self.basedir = basedir
        path = os.path.join(self.basedir, "arkivstruktur.xml")
        print(path)
        parser = etree.XMLParser(remove_blank_text=True)
        fh = open(path)
        tree = etree.parse(fh, parser)
        fh.close()
        element = tree.getroot()
        if element.tag == tagarkiv:
            (c, res) = self.json_get(self.findRelation(self.relbase + '/arkivstruktur/'))
            parentinfo = json.loads(c)
            self.import_arkiv(parentinfo, element)
    #    print(etree.tostring(tree))

def main():
    relbase = 'http://rel.kxml.no/noark5/v4/api/arkivstruktur'
    baseurl = "http://localhost:8092/noark5v4/"
    
    parser = argparse.ArgumentParser()
    parser.add_argument("--baseurl", help="(default is %s)" % baseurl)
    parser.add_argument("--verbose", help="print more debug information",
                        action="store_true")
    parser.add_argument("basedir", nargs='+', help="directory with extract")
    args = parser.parse_args()

    if args.baseurl:
        baseurl = args.baseurl

    i = Importer(baseurl)
    i.verbose = args.verbose
    i.login()

    retval = 0
    for basedir in args.basedir:
        i.loaddir(basedir)
    
    i.printstats()

    return retval

if __name__ == '__main__':
    exit(main())
